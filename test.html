<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Futuristic Grid Glow</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
  <style>
    /* Basic styling for body and html to remove default margins and set background */
    body, html {
      margin: 0;
      padding: 0;
      background-color: #0a0a0a; /* Dark background for futuristic feel */
      overflow: hidden; /* Hide scrollbars */
      font-family: "Inter", sans-serif; /* Set Inter font */
    }

    /* Grid container styling */
    .grid {
      display: grid;
      /* grid-template-columns and grid-auto-rows will be set dynamically by JavaScript */
      width: 100vw; /* Full viewport width */
      height: 100vh; /* Full viewport height */
    }

    /* Individual cell styling */
    .cell {
      box-sizing: border-box; /* Include padding and border in the element's total width and height */
      border: 1px solid rgba(255, 255, 255, 0.05); /* Subtle initial border */
      transition: border-color 0.3s ease; /* Smooth transition for border color changes */
      border-radius: 5px; /* Slightly rounded corners for cells to enhance circular glow perception */
    }
  </style>
</head>
<body>
  <div class="grid" id="grid"></div>
<!-- https://codepen.io/humming-design/pen/ExeKeMj -->




















  <script>
    const grid = document.getElementById('grid');
    const cellSize = 40; // Define the size of each grid cell in pixels
    let cols, rows; // Variables to store the calculated number of columns and rows

    const cells = []; // Array to store references to each cell element and its coordinates

    /**
     * Initializes or re-initializes the grid based on the current window size.
     * This function clears existing cells, calculates new dimensions, and creates new cells.
     */
    function initializeGrid() {
      // Clear all existing child elements from the grid container
      grid.innerHTML = '';
      // Clear the cells array to remove references to old cells
      cells.length = 0;

      // Calculate the number of columns and rows needed to fill the screen
      cols = Math.ceil(window.innerWidth / cellSize);
      rows = Math.ceil(window.innerHeight / cellSize);

      // Set the CSS grid properties dynamically to create the grid layout
      grid.style.gridTemplateColumns = `repeat(${cols}, ${cellSize}px)`;
      grid.style.gridAutoRows = `${cellSize}px`;

      // Loop to create and append each cell to the grid
      for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
          const cell = document.createElement('div');
          cell.classList.add('cell'); // Add the 'cell' class for styling
          grid.appendChild(cell); // Append the cell to the grid container
          cells.push({ x, y, el: cell }); // Store cell's coordinates and element reference
        }
      }
    }

    // Initialize the grid when the page loads
    initializeGrid();

    // Add an event listener to re-initialize the grid whenever the window is resized
    window.addEventListener('resize', initializeGrid);

    /**
     * Event listener for mouse movement.
     * Calculates the distance of each cell from the mouse and adjusts its border color.
     */
    document.addEventListener('mousemove', (e) => {
      const mouseX = e.clientX; // Get the current X coordinate of the mouse
      const mouseY = e.clientY; // Get the current Y coordinate of the mouse

      const radius = 250; // Define the radius of the circular glow effect (increased for better visibility)
      const maxAlpha = 0.6; // Maximum opacity for the border color (closest to mouse)
      const minAlpha = 0.05; // Minimum opacity for the border color (furthest from mouse within radius)

      // Iterate over each cell in the grid
      cells.forEach(({ x, y, el }) => {
        // Calculate the center coordinates of the current cell
        const cellCenterX = x * cellSize + cellSize / 2;
        const cellCenterY = y * cellSize + cellSize / 2;

        // Calculate the difference in X and Y coordinates between the mouse and cell center
        const dx = cellCenterX - mouseX;
        const dy = cellCenterY - mouseY;
        // Calculate the Euclidean distance from the mouse to the cell center
        const distance = Math.sqrt(dx * dx + dy * dy);

        // Calculate the alpha (opacity) value based on the distance from the mouse
        const alpha = distance < radius
          ? minAlpha + (1 - distance / radius) * (maxAlpha - minAlpha) // Linear interpolation for alpha within the radius
          : minAlpha; // If outside the radius, set to minimum alpha

        // Construct the RGBA color string for the cell's border
        const color = `rgba(255, 255, 255, ${alpha.toFixed(3)})`;

        // Use GSAP to smoothly animate the border color of the cell
        gsap.to(el, {
          borderColor: color, // Target border color
          duration: 0.2, // Animation duration in seconds
          overwrite: true // Ensures that only the latest animation for this element is active
        });
      });
    });
  </script>
</body>
</html>
